// ppm.js
"use strict";
var through = require("through");

// Create parser state
var PARSER_STATE = {
  HEADER: 0,
  BODY: 1,
  DONE: 2,
  ERROR: 3
};

var TOKEN_TYPE = {
  HEADER: 0,
  NUMBER: 1
};

// Removed makeToken as it's not used in the existing parsing logic directly.
// The parsing logic already handles token types within ontoken function.

function PPMParser(stream, cb) {
  this.cb = cb;
  this.buffer = [];
  this.width = 0;
  this.height = 0;
  this.depth = 0;
  this.state = PARSER_STATE.HEADER;
  this.cur_row = 0;
  this.cur_col = 0;
  this.cur_channel = -1; // -1 for P3 header, 0 for width, 1 for height, 2 for depth, then 0-2 for RGB
  this.image = [];

  this.ptr = [0, 0]; // [offset in current buffer, buffer index]

  this.stream = stream;
  this.error_cb = PPMParser.prototype.onerror.bind(this);
  this.data_cb = PPMParser.prototype.ondata.bind(this);
  this.end_cb = PPMParser.prototype.onend.bind(this);
  stream.on("error", this.error_cb);
  stream.on("data", this.data_cb);
  stream.on("end", this.end_cb);
}

// Advances the pointer (ptr) to the next character in the buffer
PPMParser.prototype.next = function(ptr) {
  ptr[0]++; // Advance offset in current buffer
  if (ptr[0] >= this.buffer[ptr[1]].length) {
    ptr[0] = 0; // Reset offset
    ptr[1]++; // Move to next buffer
    if (ptr[1] >= this.buffer.length) {
      // End of all buffers, mark as -1 to indicate invalid position
      ptr[0] = -1;
      ptr[1] = this.buffer.length;
    }
  }
};

// Gets the character at the current pointer position
PPMParser.prototype.get = function(ptr) {
  if (ptr[0] < 0 || ptr[1] >= this.buffer.length || this.buffer[ptr[1]] === undefined) {
    return -1; // Indicates end of stream or invalid position
  }
  return this.buffer[ptr[1]][ptr[0]];
};

PPMParser.prototype.ondata = function(data) {
  if (this.state === PARSER_STATE.ERROR || this.state === PARSER_STATE.DONE) {
    return;
  }

  // If previous data was completely consumed, reset buffer and pointer
  if (this.ptr[0] === -1 || this.buffer.length === 0 || this.ptr[1] === this.buffer.length) {
    this.buffer = [new Buffer(data)];
    this.ptr = [0, 0];
  } else {
    // Append new data to existing buffers
    this.buffer.push(new Buffer(data));
  }

  var current_ptr_position = [this.ptr[0], this.ptr[1]]; // Keep track of current position for tokenizing
  var token_start_ptr = [0, 0]; // Used to advance after a token is found

  while (current_ptr_position[0] !== -1 &&
         this.state !== PARSER_STATE.ERROR &&
         this.state !== PARSER_STATE.DONE) {

    // Skip comments
    if (this.get(current_ptr_position) === 35) { // '#'
      while (current_ptr_position[0] !== -1) {
        var c = this.get(current_ptr_position);
        if (c === 0x0a || c === 0x0d) { // Newline or carriage return
          this.next(current_ptr_position); // Consume the newline
          break;
        }
        this.next(current_ptr_position);
      }
      token_start_ptr = [current_ptr_position[0], current_ptr_position[1]];
      continue;
    }

    // Skip whitespace
    var char_code = this.get(current_ptr_position);
    if (char_code === 0x09 || char_code === 0x0a || char_code === 0x0b ||
        char_code === 0x0c || char_code === 0x0d || char_code === 0x20) { // Whitespace characters
      this.next(current_ptr_position);
      token_start_ptr = [current_ptr_position[0], current_ptr_position[1]];
      continue;
    }

    // Parse P3 header
    if (this.state === PARSER_STATE.HEADER && this.get(current_ptr_position) === 80) { // 'P'
      this.next(current_ptr_position);
      if (this.get(current_ptr_position) === 51) { // '3'
        this.ontoken(TOKEN_TYPE.HEADER);
        this.next(current_ptr_position); // Consume '3'
        token_start_ptr = [current_ptr_position[0], current_ptr_position[1]];
        continue;
      } else {
        this.onerror(new Error("Invalid PPM header magic number"));
        return;
      }
    }

    // Parse numbers
    if (char_code >= 48 && char_code <= 57) { // '0' - '9'
      var value = 0;
      var num_ptr = [current_ptr_position[0], current_ptr_position[1]];
      while (num_ptr[0] !== -1) {
        var x = this.get(num_ptr);
        if (x >= 48 && x <= 57) {
          value = value * 10 + (x - 48);
          this.next(num_ptr);
        } else {
          break;
        }
      }
      this.ontoken(TOKEN_TYPE.NUMBER, value);
      current_ptr_position = [num_ptr[0], num_ptr[1]]; // Update main pointer to after the number
      token_start_ptr = [current_ptr_position[0], current_ptr_position[1]];
      continue;
    }

    // If we reach here, it's an unexpected character
    if (current_ptr_position[0] !== -1) {
      this.onerror(new Error("Invalid character in token stream: " + this.get(current_ptr_position)));
      return;
    }
  }
  // Update parser's internal pointer to reflect consumed data
  this.ptr = [token_start_ptr[0], token_start_ptr[1]];

  // Clean up consumed buffers
  if (this.ptr[1] > 0) {
    this.buffer.splice(0, this.ptr[1]);
    this.ptr[1] = 0;
  }
};

PPMParser.prototype.onerror = function(err) {
  if (this.state === PARSER_STATE.ERROR || this.state === PARSER_STATE.DONE) {
    return;
  }
  this.buffer = [];
  this.image = [];
  this.stream.removeListener("data", this.data_cb);
  this.stream.removeListener("error", this.error_cb);
  this.stream.removeListener("end", this.end_cb);
  this.state = PARSER_STATE.ERROR;
  this.cb(err, null);
  this.data_cb = this.error_cb = this.end_cb = null;
};

PPMParser.prototype.ontoken = function(type, value) {
  switch (this.state) {
    case PARSER_STATE.HEADER:
      if (type === TOKEN_TYPE.HEADER) {
        // P3 header found, now expect width, height, depth
        this.cur_channel = 0; // Use cur_channel to track header values: 0=width, 1=height, 2=depth
      } else if (type === TOKEN_TYPE.NUMBER) {
        switch (this.cur_channel) {
          case 0: // Width
            this.width = value;
            break;
          case 1: // Height
            this.height = value;
            break;
          case 2: // Depth (max color value)
            this.depth = value;
            if (this.width > 0 && this.height > 0 && this.depth > 0) {
              this.image = new Array(this.height);
              for (var i = 0; i < this.height; ++i) {
                var row = new Array(this.width);
                for (var j = 0; j < this.width; ++j) {
                  row[j] = [0, 0, 0]; // Initialize RGB channels
                }
                this.image[i] = row;
              }
              this.state = PARSER_STATE.BODY;
              this.cur_col = 0;
              this.cur_row = 0;
              this.cur_channel = 0; // Reset for RGB values
            } else {
              this.onerror(new Error("Invalid PPM header dimensions/depth"));
              return;
            }
            break;
          default:
            this.onerror(new Error("Invalid PPM header token sequence"));
            return;
        }
        this.cur_channel++;
      } else {
        this.onerror(new Error("Invalid PPM file header format"));
        return;
      }
      break;

    case PARSER_STATE.BODY:
      if (type !== TOKEN_TYPE.NUMBER) {
        this.onerror(new Error("Invalid token in PPM body - expected number"));
        return;
      }
      if (this.cur_row < this.height && this.cur_col < this.width) {
        this.image[this.cur_row][this.cur_col][this.cur_channel] = value;
      } else {
        this.onerror(new Error("PPM body data out of bounds"));
        return;
      }

      this.cur_channel++;
      if (this.cur_channel >= 3) { // All RGB channels read for current pixel
        this.cur_channel = 0;
        this.cur_col++;
        if (this.cur_col >= this.width) { // All columns in current row read
          this.cur_col = 0;
          this.cur_row++;
          if (this.cur_row >= this.height) { // All rows read
            this.state = PARSER_STATE.DONE;
          }
        }
      }
      break;

    case PARSER_STATE.DONE:
    case PARSER_STATE.ERROR:
      // Ignore tokens if done or in error state
      break;

    default:
      this.onerror(new Error("Unknown parser state"));
      break;
  }
};

PPMParser.prototype.onend = function() {
  // Process any remaining data in the buffer, ensuring newlines are handled
  this.ondata(new Buffer(" ")); // A dummy space to trigger final parsing if needed

  switch (this.state) {
    case PARSER_STATE.ERROR:
      // Error already handled
      break;

    case PARSER_STATE.DONE:
      this.buffer.length = 0;
      this.cb(null, this.image);
      break;

    default:
      this.state = PARSER_STATE.ERROR;
      this.cb(new Error("Unexpected EOF: PPM image incomplete"), null);
      break;
  }
};

// Parses a ppm image
exports.parse = function(stream, cb) {
  return new PPMParser(stream, cb);
};

// Writes a PPM image to stream
function PPMWriter(image) {
  this.stream = through();
  this.image = image;
  this.cur_row = 0;
  this.cur_col = 0;
  this.drain_cb = PPMWriter.prototype.writeBody.bind(this);

  this.stream.on("drain", this.drain_cb);
  // Ensure header is written before body
  process.nextTick(PPMWriter.prototype.writeHeader.bind(this));
}

PPMWriter.prototype.writeHeader = function() {
  if (!this.image || this.image.length === 0 || this.image[0].length === 0) {
    this.stream.emit('error', new Error("Invalid image data for PPMWriter"));
    this.stream.end();
    return;
  }
  var width = this.image[0].length;
  var height = this.image.length;
  var header = "P3\n#JS PPM\n" + width + " " + height + "\n255\n";
  if (this.stream.write(header)) {
    this.writeBody();
  }
};

PPMWriter.prototype.writeBody = function() {
  while (this.cur_row < this.image.length) {
    var row = this.image[this.cur_row];
    while (this.cur_col < row.length) {
      var pixel = row[this.cur_col];
      var pixel_str = pixel.join(" ");
      if (!this.stream.write(pixel_str + (this.cur_col < row.length - 1 ? " " : "\n"))) {
        return; // Buffer full, wait for 'drain'
      }
      this.cur_col++;
    }
    this.cur_col = 0;
    this.cur_row++;
  }
  // All data written
  this.stream.removeListener("drain", this.drain_cb);
  this.stream.end();
};

// Serializes an image to a ppm stream
exports.serialize = function(image) {
  var writer = new PPMWriter(image);
  return writer.stream;
};

